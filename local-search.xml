<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MyBatis-Plus学习记录</title>
    <link href="/2025/08/21/MyBatis-Plus%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/08/21/MyBatis-Plus%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>官方文档链接🔗：<a href="https://baomidou.com/introduce/">MyBatis-Plus 帮助文档</a></p></blockquote><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>定义Mapper继承MyBatis-Plus提供的BaseMapper接口，<strong>指定泛型为操作的实体类</strong></li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">UserMapper</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">BaseMapper</span>&lt;<span class="hljs-symbol">User</span>&gt;&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><p>默认情况下：</p><ul><li>以类名驼峰转下划线作为表名</li><li>把名为id的字段作为主键</li><li>将变量名驼峰转下划线作为表的字段名</li></ul><p>不符合默认规定时候，可用注解声明，常用注解为：</p><ol><li><p><strong>@TableName</strong>：用来指定操作表明</p></li><li><p><strong>@TableId</strong>：用来指定表中的主键字段信息</p><ol><li>IdType枚举：AUTO数据库自增长,INPUT通过set自行输入,ASSIGN_ID分配ID，由MP生成id</li></ol></li><li><p><strong>@TableField</strong>：用来指定表中的普通字段信息，使用场景如下</p><ol><li>成员变量名与数据库字段名不一致时</li><li>成员变量名以is开头，且是布尔值   eg. boolean isMarried</li><li>成员变量名与数据库关键字冲突  eg. long order</li><li>成员变量不是数据库字段时</li></ol></li></ol><h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="条件构造器-Wrapper"><a href="#条件构造器-Wrapper" class="headerlink" title="条件构造器 Wrapper"></a>条件构造器 Wrapper</h2><p><strong>案例1</strong>：查询名字带o，存款大于等于1000的人的id，username，info，balance字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,username,info,balance <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%o%&#x27;</span> <span class="hljs-keyword">and</span> balance <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>利用MyBatis-Plus的QueryWrapper实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构建查询条件</span><br>QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;()<br>        .select(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>,<span class="hljs-string">&quot;balance&quot;</span>)<br>        .like(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>).ge(<span class="hljs-string">&quot;balance&quot;</span>,<span class="hljs-number">1000</span>)<br><span class="hljs-comment">// 查询</span><br>List&lt;User&gt; users = userMapper.selectList(wrapper)<br></code></pre></td></tr></table></figure><p><strong>案例2</strong>：更新用户名为jack的用户的月为2000</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> tb_user <span class="hljs-keyword">set</span> balance <span class="hljs-operator">=</span> <span class="hljs-number">2000</span> <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> jack<br></code></pre></td></tr></table></figure><p>利用MyBatis-Plus的QueryWrapper实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 要更新的数据</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>user.setBalance(<span class="hljs-number">2000</span>);<br><br><span class="hljs-comment">// 更新条件</span><br>QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;().eq(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>)<br><br><span class="hljs-comment">// 更新</span><br> userMapper.update(user, wrapper)<br></code></pre></td></tr></table></figure><p><strong>案例3</strong>：更新id为1，2，4的用户余额，扣200</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> tb_user <span class="hljs-keyword">set</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">200</span> <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>利用MyBatis-Plus的UpdateWrapper实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Long&gt; ids = List.of(<span class="hljs-number">1L</span>,<span class="hljs-number">2L</span>,<span class="hljs-number">4L</span>);<br><span class="hljs-comment">// 更新条件</span><br>UpdateWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;User&gt;()<br>        .setSql(<span class="hljs-string">&quot;balance = balance - 200&quot;</span>)<br>        .in(<span class="hljs-string">&quot;id&quot;</span>,ids);<br><span class="hljs-comment">// 更新</span><br> userMapper.update(<span class="hljs-literal">null</span>, wrapper)<br></code></pre></td></tr></table></figure><p>利用LambdaWrapper进行改造，避免字符串硬编码 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构建查询条件</span><br>LambdaQueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;User&gt;()<br>        .select(User::getId,User::getUsername,User::getInfo,User::getBalance)<br>        .like(User::getUsername,<span class="hljs-string">&quot;0&quot;</span>).ge(User::getBalance,<span class="hljs-number">1000</span>)<br><span class="hljs-comment">// 查询</span><br>List&lt;User&gt; users = userMapper.selectList(wrapper)<br></code></pre></td></tr></table></figure><h2 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h2><p>企业中要求不能在业务层编写SQL，但想简化编程，我们可以利用Wrapper来构建复杂的where条件，然后自定义SQL语句中剩下部分，步骤如下：</p><ol><li>基于Wrapper构建where条件</li><li>在mapper方法参数中用Param注解声明Wrapper变量名称，<strong>必须是ew</strong></li><li>自定义SQL，并使用Wrapper条件</li></ol><p><strong>案例</strong>：更新id为1，2，4的用户余额，扣200</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 更新条件</span><br>List&lt;Long&gt; ids = List.of(<span class="hljs-number">1L</span>,<span class="hljs-number">2L</span>,<span class="hljs-number">4L</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">amount</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-comment">// 2. 定义条件</span><br>QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;().in(<span class="hljs-string">&quot;id&quot;</span>,ids)<br><span class="hljs-comment">// 3. 调用自定义SQL方法</span><br>userMapper.updateBalanceByIds(wrapper,amount)<br><br><span class="hljs-comment">//创建方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">updateBalanceByIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper,<span class="hljs-meta">@Param(&quot;amount&quot;)</span> <span class="hljs-type">int</span> amount)</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在UserMapper.xml中完成SQL --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBlanceByIds&quot;</span>&gt;</span><br>    UPDATE tb_user SET balance = balance - #&#123;amount&#125; $&#123;ew.customSqlSegment&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h2><p>MP的Service接口实现流程：</p><ol><li>我们的自定义接口需要继承IService接口</li><li>我们的实现类需要去继承ServiceImpl实现类</li></ol><p>继承结构图如下所示：</p><p><img src="/./MyBatis-Plus%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.png" alt="Service接口继承示意图"></p><h3 id="IService的Lambda查询"><a href="#IService的Lambda查询" class="headerlink" title="IService的Lambda查询"></a>IService的Lambda查询</h3><p><strong>案例</strong>：实现一个根据复杂条件查询用户的接口，条件如下：</p><pre><code class="hljs">    - name：用户名关键字，可以为空    - status：用户状态，可以为空    - minBalance：最小余额，可以为空    - maxBalance：最大余额，可以为空</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">queryUsers</span><span class="hljs-params">(String name, Integer status, Integer minBlance, Integer maxBalance)</span>&#123;<br>    <span class="hljs-keyword">return</span> lambdaQuery()<br>            .like(name != <span class="hljs-literal">null</span> ,User::getUsername, name)<br>            .eq(status != <span class="hljs-literal">null</span>,User::getStatus, status)<br>            .ge(minBlance != <span class="hljs-literal">null</span>,User::getMinBalance, maxBalance)<br>            .le(maxBalance != <span class="hljs-literal">null</span>,User::getMaxBalance, maxBalance)<br>            .list();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="IService的批处理"><a href="#IService的批处理" class="headerlink" title="IService的批处理"></a>IService的批处理</h3><p>方案对比</p><ul><li><p>普通for循环插入新增用户，速度极差，不推荐</p></li><li><p>MP的批量新增，基于预编译的批处理，性能不错</p></li><li><p>配置jdbc参数，开启mysql的rewriteBatchedStatements&#x3D;True参数，性能最好</p></li></ul><h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>推荐插件：MyBatisPlus</p><p>Config Database -&gt; 连接数据库<br>Code Generator -&gt; 配置相关参数，如下图</p><p><img src="/./MyBatis-Plus%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2.png" alt="相关配置项说明"></p><h2 id="静态工具"><a href="#静态工具" class="headerlink" title="静态工具"></a>静态工具</h2><p>Db是一个提供静态方法的工具类，用于简化数据库操作，无需直接使用Mapper或 Service对象，在一些场景下可以更方便地进行CRUD。</p><ul><li>在工具类或非Spring管理的类中操作数据库</li><li>简单的CRUD操作</li><li>快速开发或脚本场景，避免注入多个Service&#x2F;Mapper</li></ul><h2 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h2><p>基于代码逻辑模拟删除效果，但不会真正删除数据，通过在表中添加<strong>删除标识字段</strong>来表示是否删除，当删除数据的时候将标识置为1，查询时，判断数据删除状态，只查询标记为0的数据。</p><p>应用场景：</p><ul><li>需要保留删除记录用于统计时，比如用户数据，订单记录等</li><li>软删除+回收站功能</li><li>日志需求，追踪删除时间、删除数据，便于审计</li></ul><p>使用方法：</p><p>在application.yaml中配置逻辑删除的字段名称和值就可以：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>        <span class="hljs-attr">global-config:</span><br>                <span class="hljs-attr">db-config:</span><br>                        <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">flag</span>  <span class="hljs-comment"># 全局逻辑删除的实体字段名，字段类型可以是boolean、integer</span><br>                        <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span>  <span class="hljs-comment">#逻辑已删除值(默认为1)</span><br>                        <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span>   <span class="hljs-comment">#逻辑未制除值(默认为0)</span><br></code></pre></td></tr></table></figure><p>缺点：</p><ul><li>数据库表中的垃圾数据越来越多，影响查询效率</li><li>SQL语句全部需要对逻辑删除字段做判断，影响查询效率</li></ul><p>如果需要保留删除数据，推荐采用将数据迁移到其他表的方法</p><h2 id="枚举处理器"><a href="#枚举处理器" class="headerlink" title="枚举处理器"></a>枚举处理器</h2><p>某些表中字段可能是一个状态类，可以用枚举类去表示，将状态的数字用枚举类型去改写，代码可读性变好。但数据库中，仍然使用int类去表示状态，所以采用MP的枚举处理器MybatisEnumTypeHandler来解决类型转换的问题。</p><p>使用方法：</p><ol><li>在枚举类中对应数据库的属性值加上注解@EnumValue</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">GradeEnum</span> &#123;<br>    PRIMARY(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小学&quot;</span>),<br>    SECONDARY(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;中学&quot;</span>),<br>    HIGH(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;高中&quot;</span>);<br><br>    <span class="hljs-meta">@EnumValue</span> <span class="hljs-comment">// 标记数据库存的值是code</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> code;<br>    pricate <span class="hljs-keyword">final</span> String desc;<br><br>    <span class="hljs-comment">// 其他属性...</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>在application.yaml中配置全局枚举处理器</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">default-enum-type-handler:</span> <span class="hljs-string">xx.xx.xx.MyEnumTypeHandler</span><br></code></pre></td></tr></table></figure><ol start="3"><li>修改实体类的字段为枚举类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 比如这是一个User类</span><br><span class="hljs-keyword">private</span> GradeEnum grade; <span class="hljs-comment">// 年级</span><br></code></pre></td></tr></table></figure><h2 id="JSON处理器"><a href="#JSON处理器" class="headerlink" title="JSON处理器"></a>JSON处理器</h2><p>数据库中某些表中字段的数据类型为JSON格式，而在java中用String进行表示，为了能够提取出JSON中某些属性对应的值，可以在java中定义出相关的类进行提取，然后用JSON处理器AbstractJsonTypeHandler来解决数据库Json格式与类的转换。</p><p>使用方法：</p><ol><li>定义Json对应的实体类 eg. OtherInfo类</li><li>在数据库表对应的实体类中的属性上配置Json处理器@TableField(<strong>typeHandler</strong> &#x3D; JacksonTypeHandler.class)</li><li>开启映射注解@TableName(<strong>autoResultMap</strong> &#x3D; true)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-meta">@TableName(autoResultMap = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    ...<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 必须开启映射注解</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@TableName</span>(autoResultMap = true)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 选择对应的 JSON 处理器，并确保存在对应的 JSON 解析依赖包</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(typeHandler = JacksonTypeHandler.class)</span><br>    <span class="hljs-comment">// 或者使用 FastjsonTypeHandler</span><br>    <span class="hljs-comment">// @TableField(typeHandler = FastjsonTypeHandler.class)</span><br>    <span class="hljs-keyword">private</span> OtherInfo otherInfo;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h2><h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p>使用方法：</p><ol><li>在配置类中注册MyBatisPlus的核心插件，并添加分页插件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan(&quot;scan.your.mapper.package&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加分页插件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1. 初始化核心插件</span><br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        <span class="hljs-comment">// 2. 添加分页插件</span><br>        <span class="hljs-type">PaginationInnerInterceptor</span> <span class="hljs-variable">pageIntercepter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL);<br>        pageIntercepter.setMaxLimit(<span class="hljs-number">1000L</span>); <span class="hljs-comment">// 设置分页上限（可选）</span><br>        <span class="hljs-comment">// 如果配置多个插件, 切记分页最后添加</span><br>        <span class="hljs-comment">// 如果有多数据源可以不配具体类型, 否则都建议配上具体的 DbType</span><br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用分页的API的demo</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageQuery</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 1.查询（页码，每页条数）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pageNo</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, pageSize = <span class="hljs-number">5</span>;<br>        <span class="hljs-comment">// 1.1.分页参数</span><br>        Page&lt;User&gt; page = Page.of(pageNo, pageSize);<br>        <span class="hljs-comment">// 1.2.排序参数，通过OrderItem来指定，false表示降序</span><br>        page.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(<span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-literal">false</span>));<br>        <span class="hljs-comment">// 1.3.分页查询</span><br>        Page&lt;User&gt; p = userService.page(page);<br><br>        <span class="hljs-comment">// 2.总条数</span><br>        System.out.println(<span class="hljs-string">&quot;total=&quot;</span>+ p.getTotal());<br>        <span class="hljs-comment">// 3.总页数</span><br>        System.out.println(<span class="hljs-string">&quot;pages =&quot;</span>+ p.getPages());<br>        <span class="hljs-comment">// 4.分页数据</span><br>        List&lt;User&gt; records = p.getRecords();<br>        records.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通用分页实体"><a href="#通用分页实体" class="headerlink" title="通用分页实体*"></a>通用分页实体*</h3><p>核心思路：</p><ul><li><p>定义统一的查询实体PageQuery，实现查询方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageQuery</span> &#123;<br>      <span class="hljs-keyword">private</span> Integer pageNo; <span class="hljs-comment">//页码</span><br>      <span class="hljs-keyword">private</span> Integer pageSize; <span class="hljs-comment">//页容量</span><br>      <span class="hljs-keyword">private</span> String sortBy; <span class="hljs-comment">//排序字段</span><br>      <span class="hljs-keyword">private</span> Boolean isAsc; <span class="hljs-comment">//是否升序</span><br><br>      <span class="hljs-keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="hljs-title function_">toMpPage</span><span class="hljs-params">(orderItem ... items)</span>&#123;<br>              <span class="hljs-comment">// 1.分页条件</span><br>              Page&lt;T&gt; page =Page.of(pageNo, pageSize);<br>              <span class="hljs-comment">// 2.排序条件</span><br>              <span class="hljs-keyword">if</span>(strutil.isNotBlank(sortBy))&#123;<br>                      <span class="hljs-comment">// 不为空</span><br>                      page.addorder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(sortBy isAsc));<br>              &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(items != <span class="hljs-literal">null</span>)&#123;<br>                      <span class="hljs-comment">// 为空，默认排序</span><br>                      page.addorder(items);<br>              &#125;<br>              <span class="hljs-keyword">return</span> page;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="hljs-title function_">toMpPage</span><span class="hljs-params">(String defaltSortBy, Boolean defaultAsc)</span>&#123;<br>              <span class="hljs-keyword">return</span> toMpPage(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(defaltSortBy, defaultAsc));<br>      &#125;<br><br>      <span class="hljs-comment">// 常用的默认排序可以直接定义出来，方便使用</span><br>      <span class="hljs-keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="hljs-title function_">toMpPageDefaultSortByCreateTime</span><span class="hljs-params">()</span>&#123;<br>              <span class="hljs-keyword">return</span> toMpPage(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(<span class="hljs-string">&quot;create_time&quot;</span>, <span class="hljs-literal">false</span>));<br>      &#125;<br></code></pre></td></tr></table></figure></li><li><p>封装统一的返回实体PageDTO和返回方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageDTO</span>&lt;T&gt;&#123;<br>      <span class="hljs-keyword">private</span> Long total; <span class="hljs-comment">//总条数</span><br>      <span class="hljs-keyword">private</span> Long pages; <span class="hljs-comment">//总页数</span><br>      <span class="hljs-keyword">private</span> List&lt;T&gt; list; <span class="hljs-comment">//集合</span><br><br>      <span class="hljs-comment">// PO转VO对象返回</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;PO, VO&gt; PageDTO&lt;VO&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(Page&lt;PO&gt; p, Class&lt;VO&gt; clazz)</span>&#123;<br>              PageDTO&lt;VO&gt; dto = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageDTO</span>&lt;&gt;();<br>              <span class="hljs-comment">// 总条数</span><br>              dto.setTotal(p.getTotal());<br>              <span class="hljs-comment">// 总页数</span><br>              dto.setPages(p.getPages());<br>              <span class="hljs-comment">// 当前页数据</span><br>              List&lt;PO&gt; records = p.getRecords();<br>              <span class="hljs-keyword">if</span>(CollUtil.isEmpty(records))&#123;<br>                      dto.setList(Collections.emptyList());<br>                      <span class="hljs-keyword">return</span> dto;<br>              &#125;<br>              <span class="hljs-comment">// 拷贝vo到po</span><br>              dto.setList(BeanUtil.copyToList(records, clazz));<br>              <span class="hljs-comment">// 返回</span><br>              <span class="hljs-keyword">return</span> dto;<br>      &#125;<br></code></pre></td></tr></table></figure></li><li><p>在需要分页查询的实体类中继承上述的实体，使用方法</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《大规模语言模型理论与实践》RAG章节笔记</title>
    <link href="/2025/08/21/%E3%80%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8BRAG%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/08/21/%E3%80%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8BRAG%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《大规模语言模型理论与实践》第二版：<a href="https://intro-llm.github.io/">原书资料链接🔗</a></p></blockquote><h2 id="RAG系统框架"><a href="#RAG系统框架" class="headerlink" title="RAG系统框架"></a>RAG系统框架</h2><p>RAG核心在于将<strong>外部检索</strong>与<strong>生成模块</strong>有机整合，通过动态引入外部知识来提升生成结果的准确性和可靠性。</p><p><img src="/rag_frame.png" alt="RAG系统框架" title="RAG系统框架示意图">  </p><h2 id="RAG任务分级"><a href="#RAG任务分级" class="headerlink" title="RAG任务分级"></a>RAG任务分级</h2><p>根据任务认知处理层次划分，可分为显性事实查询（Explicit Facts Query）、隐性事实查询（Implicit Facts Query）、可解释推理查询（Interpretable Rationales Query）以及隐性推理查询（Hidden Rationales Query）等四个层级。</p><h2 id="模块化RAG架构"><a href="#模块化RAG架构" class="headerlink" title="模块化RAG架构"></a>模块化RAG架构</h2><p>同济大学王昊奋教授团队借鉴了模块化设计的思想，提出了模块化检索增强生成架构（Modular RAG）。原文连接：<a href="https://ojs.aaai.org/index.php/AAAI/article/view/29934">LLMEval: A Preliminary Study on How to Evaluate Large Language Models</a></p><p><img src="/./%E3%80%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8BRAG%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/model_rag.png" alt="Modular RAG 架构"></p><h3 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h3><p>该模块的核心任务是将文档划分为可管理的chunk（块），为后续的检索和生成提供组织良好的内容基础，</p><p>目前方法：</p><ul><li>块优化：<ol><li>向量块优化：用<strong>滑动窗口</strong>方法通过在相邻片段之间引入重叠区域</li><li>语义块切分：对文档分段，并对每一段<strong>生成嵌入向量</strong>，通过比较相邻段落的向量相似度进行合并</li><li>小到大：通过将用于检索的片段与用于生成的片段分开处理</li></ol></li><li>结构优化<ol><li>层次化索引：通过建立父节点和子节点之间的关联关系，将文档内容分解为不同层次的片段，并链接到相应的节点上</li><li>知识图谱索引：通过将文档组织为图结构，明确概念与实体之间的关系</li></ol></li></ul><h3 id="检索前优化"><a href="#检索前优化" class="headerlink" title="检索前优化"></a>检索前优化</h3><p>预检索模块通过对用户查询进行重构、扩展或语义优化，能够减少语言歧义和表述模糊，从而为下游检索任务提供更精准的输入。主要模块如下：</p><ol><li><p>查询扩展：通过将单一查询<strong>扩展</strong>为多个查询的方法，用以丰富查询的内容，从而弥补原始查询中可能缺乏的细节和语义信息</p></li><li><p>查询转换：对用户输入的查询进行<strong>语义优化</strong>、<strong>语言简化</strong>或<strong>结构调整</strong>，使其更加明确和精确，便于模型识别核心意图并生成相关答案</p></li><li><p>查询结构化：将用户的查询重新构建为适应不同数据类型，例如<strong>结构化数据</strong>（如表格和图形数据）的查询</p></li></ol><h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><p>检索模块需要能够高效地处理大量的文本数据，并且需要能够准确地识别和匹配查询和文档之间的语义相似性。目前的检索主要分为：稀疏检索、稠密检索和混合检索。</p><ol><li>稀疏检索</li></ol><p><img src="/./%E3%80%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8BRAG%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/1.png" alt="稀疏检索架构图"></p><p>其特点为：</p><ul><li>是一种基于统计特征的方法</li><li>通过将查询或文档转换为稀疏向量（大部分元素为0的向量）来实现检索</li><li>适用场景：大规模文档库的检索任务</li><li>优点：计算复杂度较低，在资源有限或者实时性要求较高的场景中表现突出</li><li>缺点：在捕捉复杂语义关系上存在局限性，无法有效处理同义词、上下文语意等深层语义信息</li></ul><ol start="2"><li>稠密检索</li></ol><p><img src="/./%E3%80%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8BRAG%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/2.png" alt="稠密检索架构图"></p><p>其特点为：</p><ul><li>通过DRL将查询或文档编码为稠密向量</li><li>依赖于预训练语言模型活特定的双塔模型生成语义嵌入</li><li>优点：具有强大的语义表达能力，可以处理同义词等深层语义信息</li><li>缺点：在计算成本和存储要求方面有局限性</li></ul><ol start="3"><li>混合检索</li></ol><p>将稀疏向量和稠密向量的得分进行融合活在检索流程中分阶段使用</p><p><img src="/./%E3%80%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8BRAG%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/3.png" alt="混合检索架构图"></p><h2 id="检索后优化"><a href="#检索后优化" class="headerlink" title="检索后优化"></a>检索后优化</h2><p>通过对检索内容进行后处理，解决“中间遗忘”、“噪声&#x2F;反事实”文本以及上下文窗口长度有限等问题。该部分的常见组成部分包括重排序（Rerank）、内容压缩以及内容选择等步骤。</p><ol><li><p>重排序<br>其主要目的是对检索到的文章片段（chunks）进行重新排序，以提升结果的相关性和多样性。</p><ol><li>基于规则：计算指标对chunk进行排序；指标包多样性，相关性和最大边际相关性</li><li>基于模型：计算chunk与查询之间的相关性来排序</li></ol></li><li><p>内容压缩<br>压缩的核心目标是通过内容压缩减少噪声，同时保留信息完整性，以提高语言模型的推理效率。</p><ol><li>通过小语言模型对检索内容进行对齐和预训练</li><li>利用大语言模型对检索内容进行评估</li></ol></li><li><p>内容选择<br>关键在于计算输入内容的自信息量（一种衡量内容信息价值的指标）</p></li></ol><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>生成模块是整个 RAG 系统的的核心模块，负责利用大语言模型结合用户查询与检索到的上<br>下文信息生成答案</p><h2 id="编排"><a href="#编排" class="headerlink" title="编排"></a>编排</h2><p>编排模块是RAG系统<strong>核心控制单元</strong>，负责在关键节点进行决策并动态选择后续步骤。主要模块包括路由（Routing）、调度（Scheduling）以及融合（Fusion）。</p><ol><li><p>路由<br>通过路由机制将查询分配到针对不同场景设计的特定管道中</p><ol><li>元数据路由：</li></ol><pre><code class="hljs"> a. 基于查询中提取的关键术语或实体，通过与预设关键词集合的匹配来优化路由流程 b. 适合对显性关键词高度敏感的场景 c. 匹配分数由关键词的重叠比例计算得出</code></pre><ol start="2"><li>语义路由</li></ol><pre><code class="hljs"> a. 依赖查询的语义信息，通过语言模型计算查询与预定义意图的匹配概率</code></pre><ol start="3"><li>混合路由</li></ol><pre><code class="hljs"> a. 通过引入权重因子，混合路由在元数据匹配和语义分析之间找到平衡点，从而实现更精确的路由选择</code></pre></li><li><p>调度<br>   调度模块的作用是识别关键节点，负责管理和协调系统的各个流程，是否需要启动进一步的检索等</p><ol><li>规则判定：</li></ol><pre><code class="hljs">a. 用于评估生成答案的质量并决定进一步的操作b. 通过评分机制对生成的答案进行质量评估，并根据预设的阈值判断是否继续或终止生成过程</code></pre><ol start="2"><li>LLM判断</li></ol><pre><code class="hljs">a. 利用LLM的上下文学习能力b. 通过对LLM进行微调</code></pre><ol start="3"><li>知识引导调度</li></ol><pre><code class="hljs">a. 通过知识图谱引导信息检索与生成过程</code></pre></li><li><p>融合<br>当系统拓宽检索范围或探索多条管道以提升生成内容的多样性时，融合模块负责高效<strong>整合</strong>各分支生成的信息。融合模块主要包含大语言模型融合、加权集成以及倒数排名融合等方法。</p><ol><li><p>大语言模型融合：<br>  利用大语言模型强大的分析与整合能力，将不同分支的信息进行统一处理。为了解决超出上下文窗口限制的长答案时，通过先对每个分支的答案进行<strong>摘要提取</strong>后再输入LLM的方式来进行整合。</p></li><li><p>加权集成：<br>  是一种基于多分支生成结果的加权选择方法，通过不同分支生成的词元（token）的加权值来综合选择最终输出。</p></li><li><p>倒数排名融合：<br>  它通过一种定制的<strong>加权平均方法</strong>，增强了整体预测性能与排名精度。适合处理模型或来源异构的场景。</p></li></ol></li></ol><h2 id="RAG系统模式"><a href="#RAG系统模式" class="headerlink" title="RAG系统模式"></a>RAG系统模式</h2><h3 id="线性模式"><a href="#线性模式" class="headerlink" title="线性模式"></a>线性模式</h3><p>线性模式是最简单且最常用的工作流模式，其流程可以分为几个核心模块，包括预检索（Pre-Retrieval）、检索、后检索（Post-Retrieval）以及生成模块。</p><p><img src="/4.png" alt="线性模型流程"></p><h3 id="条件模式"><a href="#条件模式" class="headerlink" title="条件模式"></a>条件模式</h3><p>条件模式是一种灵活的 RAG 流模式，其核心特点是在不同条件下选择不同的 RAG 流水线，<br>从而针对特定场景进行优化。具体来说，条件模式通过一个<strong>路由模块</strong>（Routing Module）实现模块的动态选择，该模块根据输入问题的性质决定接下来的流程。</p><p><img src="/./%E3%80%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8BRAG%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/5.png" alt="条件模型流程"></p><p>条件模式的分支流通常在以下几个方面存在差异：检索来源、流程、模型配置以及提示设计</p><h3 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h3><p>分支模式通过<strong>并行运行</strong>多个分支的方式增加结果的多样性和鲁棒性。具体来说，分支模式在某个模块中生成多个并行分支，每个分支可以独立执行相同或不同的 RAG 流程。这些流程由多个处理模块组成，生成各自的分支输出结果。</p><p>分支模式可以根据不同任务需求设计为多种结构类型，通常分为两类：预检索分支模式、后检索分支模式。</p><h3 id="预检索分支-Pre-Retrieval-Branching"><a href="#预检索分支-Pre-Retrieval-Branching" class="headerlink" title="预检索分支(Pre-Retrieval Branching)"></a>预检索分支(Pre-Retrieval Branching)</h3><p>是一种通过生成多个<strong>子查询并行检索</strong>的模式，用于提高检索的全面性和生成结果的多样性。</p><p><img src="/./%E3%80%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8BRAG%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/6.png" alt="预检索分支流程"></p><h3 id="后检索分支-Post-Retrieval-Branching"><a href="#后检索分支-Post-Retrieval-Branching" class="headerlink" title="后检索分支(Post-Retrieval Branching)"></a>后检索分支(Post-Retrieval Branching)</h3><p>该模式从<strong>单一查询</strong>开始，通过<strong>检索模块</strong>获取多个文档块。每个文档块被独立送入生成模块进行处理，生成对应的结果集合。随后，这些生成的结果通过合并模块进行整合，形成最终结果。</p><p><img src="/./%E3%80%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8BRAG%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/7.png" alt="后检索分支流程"></p><h3 id="循环模式"><a href="#循环模式" class="headerlink" title="循环模式"></a>循环模式</h3><p>循环模式的核心是检索与生成步骤之间的<strong>相互依赖性</strong>。循环模式通过引入调度模块进行控制，确保系统可以根据需要在特定模块之间<strong>重复执行</strong>某些操作。</p><p>循环模式的关键在于<strong>判断模块</strong>（Judge Module），用于决定流程是否需要返回到之前的模块或继续向下执行。</p><p>循环模式可以进一步细分为三种类型：迭代型、递归型和自适应型（主动型）检索模式。</p><ol><li>迭代型循环模式：通过多次循环执行<strong>检索</strong>和<strong>生成</strong>操作，在每次迭代中逐步优化结果。在每一步迭代中，系统根据当前查询和之前的输出结果，检索相关的文档片段，然后利用这些文档生成新的输出。迭代过程通常设置一个<strong>最大迭代次数</strong>的限制，以避免无限循环。</li></ol><p><img src="/./%E3%80%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8BRAG%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/8.png" alt="迭代型循环模式"></p><ol start="2"><li>递归型循环检索模式：一种具有明显<strong>依赖性</strong>和<strong>层次性</strong>的检索方式。其显著特点在于每一步都依赖于前一步的输出，并通过不断加深检索过程，逐步挖掘更深层次的信息。递归型检索还包含明确的<strong>退出机制</strong>，用以确保在满足终止条件时流程终止，避免无限递归。递归型循环模式通过查询转换模块生成新的查询，以推动检索逐层深入。</li></ol><p><img src="/./%E3%80%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8BRAG%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/9.png" alt="递归型循环检索模式"></p><ol start="3"><li><p>自适应型（主动型）模式：是一种超越传统被动检索模式的新兴模式，这种模式的核心思想类似于大语言模型智能体，通过<strong>动态调整检索流程</strong>，主动决定何时进行检索以及何时终止流程并生成最终结果。  </p><p> 自适应型检索通常根据判断标准进一步细分为两种方法：基于提示的方法和基于指令微调的方法。</p><ol><li>基于提示的方法：通过<strong>设计动态提示</strong>对模型进行引导；</li><li>基于指令微调的方法：利用<strong>指令微调</strong>的方法实现更精准的检索控制。</li></ol></li></ol><p><img src="/./%E3%80%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8BRAG%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/10.png" alt="自适应型（主动型）模式"></p><h2 id="RAG系统训练与优化"><a href="#RAG系统训练与优化" class="headerlink" title="RAG系统训练与优化"></a>RAG系统训练与优化</h2>]]></content>
    
    
    <categories>
      
      <category>LLM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis项目及原理总结</title>
    <link href="/2025/08/20/Redis%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <url>/2025/08/20/Redis%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis项目及原理总结"><a href="#Redis项目及原理总结" class="headerlink" title="Redis项目及原理总结"></a>Redis项目及原理总结</h1><h2 id="1-Redis基础"><a href="#1-Redis基础" class="headerlink" title="1. Redis基础"></a>1. Redis基础</h2><p>Redis是一种<strong>NoSQL</strong>数据库，采用内存存储，读写速度远超磁盘存储的SQL数据库，适合于分布式设计，方便进行扩容，提供过期时间，发布订阅，lua脚本等功能。</p><p><img src="/./Redis%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/nosql.png" alt="SQL vs NoSQL" title="SQL与NoSQL的对比"></p><p>Redis提供丰富的数据类型，常见的5种数据类型为：<strong>String(字符串)，Hash(哈希)，List(列表)，Set(集合)，Zset(有序集合)</strong>。随着版本更新，后面又新增支持了四种数据类型：<strong>BitMap(位图)，HyperLogLog(超日志)，GEO(地理空间)，Stream(流)</strong> 。这些数据类型在后面的项目中都有应用到，概括来说，他们的应用场景为：</p><ul><li>String类型：缓存对象，共享session，常规计数等 </li><li>Hash类型：缓存对象，可以只修改某一项属性值</li><li>List类型：消息队列，但注意只支持单消费者</li><li>Set类型：共同好友，聚合计算（求交集，并集）</li><li>Zset类型：排序场景，例如排行榜</li><li>BitMap类型：二值状态统计场景，比如签到表</li><li>HyperLogLog类型：海量数据基数统计，比如百万级UV统计</li><li>GEO类型：存储地理位置信息场景，比如附近商户</li><li>Stream类型：消息队列，提供消费者组模式</li></ul><p>Redis命令，详见<a href="https://www.runoob.com/redis/redis-commands.html">菜鸟教程Redis命令</a>。</p><h2 id="2-Redis项目——黑马点评"><a href="#2-Redis项目——黑马点评" class="headerlink" title="2. Redis项目——黑马点评"></a>2. Redis项目——黑马点评</h2><h3 id="2-1-短信验证码登录"><a href="#2-1-短信验证码登录" class="headerlink" title="2.1 短信验证码登录"></a>2.1 短信验证码登录</h3><h4 id="基于Session实现登录"><a href="#基于Session实现登录" class="headerlink" title="基于Session实现登录"></a>基于Session实现登录</h4><p>业务流程：  </p><ol><li>发送短信验证码</li><li>短信验证码登录、注册</li><li>校验登录状态<br><img src="/./Redis%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/login_basesession.png" alt="session登录流程" title="基于session登录流程"></li></ol><p>缺点：</p><ol><li><strong>水平扩展困难</strong>：如果有多台tomcat服务器，session不便于水平扩展，因为session存储在单个服务器的内存中，用户请求必须始终路由到同一台服务器才能得到正确的数据</li><li><strong>验证码状态管理不灵活</strong>：Session会随着会话结束而失效，但短信验证码需要更短的有效期，需要额外逻辑管理验证码过期时间</li></ol><h4 id="基于Redis实现登录"><a href="#基于Redis实现登录" class="headerlink" title="基于Redis实现登录"></a>基于Redis实现登录</h4><p>两个地方需要用Redis来进行数据缓存：</p><ol><li>验证码（生成验证码-校验验证码）；</li><li>用户信息（登录用户-用户登录状态校验）。</li></ol><p>如何选择key和value？明确key的要求：唯一性，方便携带和提取。  </p><ol><li>验证码：<ol><li>key-设置为手机号，方便客户端取出信息进行验证（原来基于Session实现，客户端通过Cookie携带SessionId来自动取出）；</li><li>value-验证码，数据类型选择为最简单的String就可以实现</li></ol></li><li>用户信息：<ol><li>key-设置为随机token作为登录凭证（这里不用手机号的原因是手机号作为登录凭证返回给前端不安全）；</li><li>value-用户信息，有两种数据类型可以选择，一是采用String类型，以JSON字符串存储，适合用户信息较少的情况，耦合性较高。二是采用Hash类型，field就是用户属性，value就是属性值</li></ol></li></ol><p>业务流程：</p><p>总体流程与基于session登录类似，不同点在于验证码和用户状态需要缓存在redis中，然后在校验时，需从redis中读取验证</p><p><img src="/./Redis%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/redislogin.png" alt="redis登录流程1" title="基于redis登录流程1">  </p><p><img src="/./Redis%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/redislogin2.png" alt="redis登录流程2" title="基于redis登录流程2">  </p><p>代码实现：</p><ol><li>发送短信验证码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">//1. 校验手机号</span><br>    <span class="hljs-keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;<br>        <span class="hljs-comment">//2. 如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3. 符合，生成验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">//4. 保存验证码到redis</span><br>    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code,LOGIN_CODE_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">//5. 发送验证码</span><br>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码为：&quot;</span> + code);<br>    <span class="hljs-comment">// 返回ok</span><br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：此处验证码发送功能仅实现模拟，后续将使用腾讯云提供的短信服务实现真实地短信发送功能</p><ol start="2"><li>根据验证码进行登录&#x2F;注册</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">//1.校验手机号</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>        <span class="hljs-keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;<br>            <span class="hljs-comment">//2. 如果不符合，返回错误信息</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//3. 从redis中获取验证码并校验</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">cachCode</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>        <span class="hljs-keyword">if</span>(cachCode == <span class="hljs-literal">null</span> || !cachCode.equals(code))&#123;<br>            <span class="hljs-comment">//不一致，报错</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//4. 一致，根据手机号查询用户信息 select * from tb_user where phone= ? 用mybatisplus来实现</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br>        <span class="hljs-comment">//query 相当于 select * from tb_user；eq 相当于 = ;  查多个结果就是list() ; 查一个结果就是one();</span><br><br>        <span class="hljs-comment">//5. 判断用户是否存在</span><br>        <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//6. 不存在，创建新用户，并保存到数据库</span><br>            <span class="hljs-comment">// 注意还需要返回这个创建的用户，因为后面需要保存用户信息到session</span><br>            user = createUserWithPhone(phone);<br>        &#125;<br><br>        <span class="hljs-comment">//7. 用户存在，保存用户信息到redis中：</span><br>        <span class="hljs-comment">// 7.1 生成随机token作为登录令牌和key</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 7.2 将user对象转换为hash存储到value中————先转成map&lt;hashkey,value&gt;，再用putall一次性存入，不然要多次交互，很麻烦</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>        <span class="hljs-comment">// 由于userDTO对象中的id是long类型的，在保存信息的时候map中的&lt;id,991&gt;中的value是long类型，而stringRedisTemplate要求为String类型，所以需要转换</span><br>        Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(<br>                userDTO,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>                CopyOptions.create()<br>                .setIgnoreNullValue(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 忽略值为 null 的字段</span><br>                .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()) <span class="hljs-comment">// 字段值处理器，处理long型的id值</span><br>        );<br>        <span class="hljs-comment">// 7.3 保存信息</span><br>        stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY + token, userMap);<br>        <span class="hljs-comment">// 7.4 设置token有效期，并通过拦截器更新token有效期</span><br>        stringRedisTemplate.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);<br><br>        <span class="hljs-comment">//8. 返回token给前端</span><br>        <span class="hljs-keyword">return</span> Result.ok(token);<br>    &#125;<br>```  <br><br><span class="hljs-number">3.</span> 校验登录状态<br>  <br>通过两个拦截器来实现，一个token刷新拦截器，一个login拦截器。<br><br>不设置成一个拦截器的原因是，如果把token刷新逻辑也放在login拦截器中，会出现一个情况：已经登录的用户访问那些无需登录权限的页面时，不会触发token刷新，可能导致活跃的登录用户突然要求再次登录，这不符合业务需求。<br><br>注册拦截器：<br><br>```java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//登录拦截器：指定不用拦截的路径</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>                .excludePathPatterns(<br>                <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                <span class="hljs-string">&quot;/user/login&quot;</span>,<br>                <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                <span class="hljs-string">&quot;/upload/**&quot;</span>,<br>                <span class="hljs-string">&quot;/voucher/**&quot;</span><br>        ).order(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//token刷新拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">0</span>); <br>        <span class="hljs-comment">//拦截所有请求，并且最先执行，通过order指定拦截器的顺序</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>token刷新拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//前置拦截，在controller执行之前去完成——去做用户信息校验</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//1. 获取请求头中的token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>    <span class="hljs-keyword">if</span>(StrUtil.isBlank(token))&#123;<br>        <span class="hljs-comment">//token为空，放行到loginInterceptor进行路径拦截校验</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//2. 基于token获取redis中的用户</span><br>    <span class="hljs-comment">// 注意不是用get（key,filed）,它返回的只是key中某个hashkey的value，要用entries，获取map&lt;&gt;</span><br>    Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);<br>    <span class="hljs-comment">// 3. 判断用户是否存在</span><br>    <span class="hljs-keyword">if</span>(userMap.isEmpty())&#123;<br>        <span class="hljs-comment">// 4. 不存在，放行到loginInterceptor进行路径拦截校验</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//5. 存在，将redis中获取的hash数据转换成UserDTO对象,不忽略错误</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 6. 保存到当前线程中</span><br>    UserHolder.saveUser(userDTO);<br>    <span class="hljs-comment">// 7. 刷新token有效期</span><br>    stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">// 8. 放行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//在视图渲染后拦截，返回给用户之前——销毁用户信息，避免内存泄露</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 移除用户</span><br>    UserHolder.removeUser();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>login拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//前置拦截，在controller执行之前去完成——去做用户信息校验</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1. 判断是否需要拦截（threadlocal中是否有用户——校验登录状态）</span><br>    <span class="hljs-keyword">if</span>(UserHolder.getUser() == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">// 没有登录状态，拦截</span><br>        response.setStatus(<span class="hljs-number">401</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 有用户，放行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-商铺查询缓存"><a href="#2-1-商铺查询缓存" class="headerlink" title="2.1 商铺查询缓存"></a>2.1 商铺查询缓存</h3><h4 id="缓存的意义"><a href="#缓存的意义" class="headerlink" title="缓存的意义"></a>缓存的意义</h4><p>缓存的核心作用是<strong>提高性能、减轻数据库压力、改善用户体验</strong>。它的适用场景包括<strong>热点数据频繁访问、数据变化不频繁、分布式系统共享数据</strong>。</p><p>缓存有几种常用类型，分别是<strong>1. 本地缓存</strong>：JVM内存缓存（如Caffeine、Guava），访问快但是仅限单机；<strong>2. 分布式缓存</strong>：Redis、Memcached，适合集群、分布式场景；<strong>3. 浏览器缓存</strong>：HTTP Cache-Control，让客户端缓存数据，减轻服务器压力</p><h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><ol><li><strong>内存淘汰LRU</strong>：Redis自带机制，当Redis内存不足的时候，根据策略删除部分key，常用策略有：volatile-lru，只对设置了TTL的Key进行LRU淘汰；allkeys-lru，对所有Key使用LRU淘汰；还有volatile-random、allkeys-random、volatile-ttl 等</li><li><strong>过期淘汰</strong>：利用expire命令给数据设置过期时间</li><li><strong>主动更新</strong>：主动完成数据库与缓存的同时更新</li></ol><p>如何选择更新策略？根据一致性需求，低一致性需求下，采用内存淘汰或过期淘汰；高一致性需求下，采用主动更新为主，过期淘汰为辅的策略。</p><p>  <strong>主动更新策略</strong>：</p><ol><li>写时更新 Write-Through：每次写数据库，同时更新缓存。缓存与数据库集成为一个服务，服务保证两者的一致性，对外暴露API接口。调用者调用API，无需知道自己操作的是数据库还是缓存，不关心一致性。优点是<strong>一致性优秀</strong>，但是<strong>实现复杂</strong>，性能一般</li><li>写时回写 Write-Back：先更新缓存，然后异步写入数据库。缓存调用者的CRUD都针对缓存完成。由独立线程异步的将缓存数据写到数据库，实现最终一致。优点是<strong>性能好</strong>，但<strong>一致性差</strong>，实现复杂</li><li>延迟加载缓存 Cache Aside：缓存不存在或过期时，才从数据库加载并写入缓存，缓存调用者在更新数据库的同时完成对缓存的更新。一致性良好，实现难度一般</li></ol><p>三种策略的对比</p><table><thead><tr><th>特性</th><th>Cache Aside</th><th>Write-through</th><th>Write-behind</th></tr></thead><tbody><tr><td><strong>读操作</strong></td><td>先查缓存，未命中查数据库</td><td>直接读缓存</td><td>直接读缓存</td></tr><tr><td><strong>写操作</strong></td><td>先写数据库，更新&#x2F;删除缓存</td><td>写数据库 + 更新缓存</td><td>写缓存 → 异步写数据库</td></tr><tr><td><strong>一致性</strong></td><td>最终一致</td><td>强一致</td><td>弱一致</td></tr><tr><td><strong>性能</strong></td><td>首次访问慢</td><td>写慢、读快</td><td>写快、读快</td></tr><tr><td><strong>适用场景</strong></td><td>高读低写、热点不固定</td><td>写少、要求一致性</td><td>高频写、允许短暂不一致</td></tr></tbody></table><p>  Cache Aside在写操作时，对缓存的操作有两种：一是更新缓存，二是删除缓存；对于<strong>更新缓存</strong>，可能存在<strong>无效更新</strong>和较大的<strong>线程安全问题</strong>，而<strong>删除缓存</strong>，本质上是<strong>延迟更新</strong>，没有无效更新，线程安全问题也较低。在单体系统中，利用<strong>事务机制</strong>确保数据库和缓存操作的原子性；在分布式系统中，利用分布式事务机制保证原子性。</p><p>  最终实现机制：</p><ul><li>读操作时：1. 先查缓存，如果命中，直接返回； 2. 缓存没命中，查数据库； 3. 将数据库数据写入缓存； 4. 返回缓存结果</li><li>写操作时：1. 先修改数据库；2. 再删除缓存  <strong>注意确保两步的原子性</strong></li></ul><h4 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h4><p><img src="/./Redis%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/shopcache1.png" alt="redis登录流程1" title="基于redis登录流程1">  </p><h4 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h4><h4 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h4><h4 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a>缓存击穿问题</h4><h2 id="Redis的分布式"><a href="#Redis的分布式" class="headerlink" title="Redis的分布式"></a>Redis的分布式</h2><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><h4 id="RDB-Redis-Database-Backup-File"><a href="#RDB-Redis-Database-Backup-File" class="headerlink" title="RDB(Redis Database Backup File)"></a>RDB(Redis Database Backup File)</h4><p>Redis数据备份文件，也叫Redis数据快照，就是将内存中的所有数据都记录到磁盘中。当故障后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认保存在当前运行目录。  </p><ul><li>save命令：由Redis主进程来执行RDB，会阻塞所有命令  </li><li>bgsave命令：开启子进程执行RDB，避免主进程受影响</li></ul><p>Redis内部可以设置触发RDB的机制，在redis.conf文件中进行修改。eg. save 5 1 表示在5s内，如果至少有1个key被修改就会执行一次bgsave。其执行流程为，fork主进程得到一个子进程，拷贝页表，共享内存空间，子进程读取内存并写入新的RDB文件，用新的RDB文件替换旧的RDB文件。</p><p>RDB缺点：</p><ul><li>执行间隔时间长，两次RDB之间写入数据有丢失的风险；</li><li>fork子进程、压缩、写RDB文件都比较耗时。</li></ul><h4 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h4><p>Redis追加文件，将Redis处理的每个写命令记录在AOP文件，可以看作命令日志文件。AOF默认是关闭的，需要修改redis.conf配置文件来开启(appendonly yes)和修改命令记录频率(appendfsysnc always&#x2F;everysec&#x2F;no 分别表示l立即&#x2F;每隔1s将&#x2F;由操作系统决定何时将缓存区内容写到aof文件)。</p><p>因为是记录命令，所以AOF文件会很大，并且多次写操作只有最后一次有意义，可以通过bgrewriteaof命令，执行重写操作，用最少命令达到相同效果。同样修改redis.conf文件来配置</p><h4 id="持久化方案对比"><a href="#持久化方案对比" class="headerlink" title="持久化方案对比"></a>持久化方案对比</h4><table><thead><tr><th></th><th><strong>RDB</strong></th><th><strong>AOF</strong></th></tr></thead><tbody><tr><td><strong>持久化方式</strong></td><td>定时对整个内存做快照</td><td>记录每一次执行的命令</td></tr><tr><td><strong>数据完整性</strong></td><td>两次备份之间的数据会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td><strong>文件大小</strong></td><td>会有压缩，文件体积小</td><td>记录命令，文件体积较大</td></tr><tr><td><strong>恢复速度</strong></td><td>很快</td><td>慢，要重新执行命令</td></tr><tr><td><strong>恢复优先级</strong></td><td>低，因为完整性不如AOF</td><td>高，因为数据完整性更高，优先用AOF恢复</td></tr><tr><td><strong>系统资源占用</strong></td><td>高，大量CPU和资源消耗</td><td>低，主要是磁盘IO资源，但重写时会占用大量CPU和内存资源</td></tr><tr><td><strong>适用场景</strong></td><td>可以容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性较高</td></tr></tbody></table><h3 id="Redis主从集群"><a href="#Redis主从集群" class="headerlink" title="Redis主从集群"></a>Redis主从集群</h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
